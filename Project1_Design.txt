CMSC 326
Design Document for Project #1: Alarms and Priority Scheduling with Priority Donation
Due: 28.March.2018

---- GROUP ----

Sasha Fedchin <af9562@bard.edu>
Karina Salem <ks5130@bard.edu>
Darren Tirto <dt2925@bard.edu>

---- PRELIMINARIES ----



---- DATA STRUCTURES ----

STUCTURE 1: Threads
Location: src/threads/thread.h
Three new elements were added to the thread structure specifically for the timer_sleep function to put . "awake_time" so we could keep track of each threads time to wake up. "awake_sem" was so that we could sleep and wake specific threads and "awake_elem" was to store them in a list so that we could store sleeping threads. 
@@ -4,6 +4,7 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
+#include "threads/synch.h"
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -100,6 +101,11 @@
 
     /* Owned by thread.c. */
     unsigned magic;                     /* Detects stack overflow. */
+
+    /* Elements used for putting threads to sleep */
+    int64_t awake_time;                 /* The time (in ticks) to wake up */
+    struct semaphore awake_sem;         /* Unique semaphore to put thread to sleep */
+    struct list_elem awake_elem;        /* List element to put this thread in a list */
   };
 
 /* If false (default), use round-robin scheduler.
@@ -138,4 +144,7 @@
 int thread_get_recent_cpu (void);
 int thread_get_load_avg (void);
 
+/*Define a function used for list_max() to order according to priority */
+list_less_func priority_is_less;

---- ALGORITHMS ----

How is priority scheduling implemented?  Refer critical data structures and the procedures where they are modified.
	
	In next_thread_to_run, we search the ready_list for the highest-priority thread and allow this thread to run next. We created sort_by_max_elem function, which is  a helper function used together with the built-in list_max procedure.	

 	The thread_set_priority changes the base priority of the thread itself, which is the default priority that the thread sets after a donation.
 	To recalculate the actual priority we use the update_actual_priority function. 
 	

Briefly describe your implementation of lock_acquire.
	
	In lock_acquire, we first make a call to lock_try_acquire. Lock_try_acquire  returns false, if the lock is already held by some thread. In this latter case, we insert the current thread into the donation list of the thread that currently holds the lock (making sure that the donation list is kept sorted). We then update the priority of the holder of the lock by making a call to update_thread_priority described below.

Briefly describe your implementation of lock_release.

How do you deal with multiple locks?
	

How do you deal with nested locks?

	We created update_thread_priority - a recursive function that updates the priority of a given thread and, if necessary, the priority of the thread on which the given thread has to wait. This function also ensures that every donation_list is kept sorted by threads' priorities. Update_thread_priority is called within thread_acquire, which modifies the donation_list and set_priority, which modifies the base priority of a thread.


---- SYNCHRONIZATION ----

How do you avoid race conditions within lock_acquire and lock_release?



---- RATIONALE ----

ALARM: For this problem, we combined two different solutions we came up with. One used semaphore elements in their threads, but checked every thread each tick and wake up ones that need to be woken up (being very time inefficient). The other created a semaphore that cooresponded to a thread that went to sleep and stored those semaphores in a list, waking them up at the calculated time (being very space inefficient or functionality limiting).

Our solution instead used both by having a calculated time to wake up element as well as a semaphore element in the thread structure. Then by putting the the thread in a list ordered by time to wake up, we iterate from the front of the list until we get through all threads that need to be woken up at that tick time.

By putting the semaphore in the thread struct, we manage to not have to constantly malloc and free new semaphores each time a thread goes to sleep. Furthermore, by using an ordered list, at every tick, we don't have to iterate through all running threads giving a time efficiency. A disadvantage to this design choice is that unlike both smaller solutions, we are allocating creating things that might never be used (such as the awake_semaphores given to threads that may never sleep as well as the list to store the sleeping threads). Under the assumptions that the sleep function will be widely used often and by many threads, these created things help the overall efficientcy.



PRIORITY DONATION: 
	In order for priority donation to be implemented, each thread has to have access
to all of its donors. This way, when the lock is released, the priorities of the thread that released the lock and the thread that got it can be reevaluated. One solution that we initially implementeed was to have a list of donors for every thread. The solution that we decided to switch to was to have the list of acquired locks for every thread. The latter approach has a number of important benefits:
	1) It costs less memory to have a list of locks when to have a list of donors, because the overall number of locks should (in most situations) be less than the number of threads. Moreover, each lock already has a list of threads that are waiting on it (accessed as lock.semaphore.waiters). 
	2) When a thread A releases the lock, and there are multiple threads waiting on this lock, a thread B will be chosen to have the lock after A. The rest of the threads waiting on the lock should cease donating their priority to A and start donating their priority to B. If the information about donations in stored in the list of locks, this is a O(1) operation. In the other case, it is O(n) operation, where n is the number of threads waiting on the lock.

the lock can be calculated For this problem, we gave each thread a list that holds the incoming donations. When it is called to update through the function "update_actual_priority". When a thread hits a lock, all it does is adds to the list of the thread it wants to donate to and tells the thread to update its priority. This solution manages to discriminate between a thread's actual priority and its "base" priority, which is the priority that it returns to after being a doner.

Notice then that we need to deal with relaying donations. Suppose we have an ordering of priority of A>B>C If thread A and thread B are both waiting on lock 1 which thread C currently owns, when thread C releases the lock, A obtains the lock and B must be donating to A (in case A tries to lower its base priority).

Another option we could have used was to keep a list of locks that a thread holds. This would have given a more direct solution as we could have just 
