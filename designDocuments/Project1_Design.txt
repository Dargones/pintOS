CMSC 326
Design Document for Project #1: Alarms and Priority Scheduling with Priority Donation
Due: 28.March.2018

---- GROUP ----

Sasha Fedchin <af9562@bard.edu>
Karina Salem <ks5130@bard.edu>
Darren Tirto <dt2925@bard.edu>

---- PRELIMINARIES ----

N/A

---- DATA STRUCTURES ----

STUCTURE 1: Threads
Location: src/threads/thread.h
For the alarm assignment we added 3 things: (1)An integer storing the tick at which the thread should wake up, (2)A semaphore that uniquely puts this thread to sleep (3) a list_elem to put this thread on a list to keep track of sleeping threads.

For the priority donation assignement we added 3 other things: (1)An integer storing a base priority (read next section), (2)A lock to that the thread is waiting on (3)as well as a list of locks that this thread has currently aquired
@@ -87,7 +88,11 @@
     enum thread_status status;          /* Thread state. */
     char name[16];                      /* Name (for debugging purposes). */
     uint8_t *stack;                     /* Saved stack pointer. */
-    int priority;                       /* Priority. */
+    int priority;                       /* Actual priority. It may change when
+    somebody donates priority to the thread*/
+    int base_priority;                  /* The base priority that can only be
+    changed when the thread is initialized, or if the thread calls
+    set_priority()*/
     struct list_elem allelem;           /* List element for all threads list. */
 
     /* Shared between thread.c and synch.c. */
@@ -100,6 +105,16 @@
 
     /* Owned by thread.c. */
     unsigned magic;                     /* Detects stack overflow. */
+
+    /* Elements used for putting threads to sleep */
+    int64_t awake_time;                 /* The time (in ticks) to wake up */
+    struct semaphore awake_sem;         /* Unique semaphore to put thread to sleep */
+    struct list_elem awake_elem;        /* List element to put this thread in a list */
+
+    /* Lock that thread attempts to hold or holds */
+    struct lock *want_lock;  /* The lock on which the thread currently waits */
+
+    struct list lock_list; /* The list of locks this thread acquired */
   };

STRUCTURE 2: Semaphore elem
Location: src/threads/synch.c
@@ -251,6 +305,7 @@
struct semaphore_elem 
   {
     struct list_elem elem;              /* List element. */
     struct semaphore semaphore;         /* This semaphore. */
+    struct thread *thread_waiting;    /* Thread that waits on the semaphore. */
   };

---- ALGORITHMS ----

How is priority scheduling implemented?  Refer critical data structures and the procedures where they are modified.
	
	In next_thread_to_run, we search the ready_list for the highest-priority thread and allow this thread to run next. We created sort_by_max_elem function, which is  a helper function used together with the built-in list_max procedure.	

 	The thread_set_priority changes the base priority of the thread itself, which is the default priority that the thread sets after a donation.
 	To recalculate the actual priority we use the update_actual_priority function. 
 	

Briefly describe your implementation of lock_acquire.
	
	In lock_acquire, we first make a call to lock_try_acquire. Lock_try_acquire  returns false, if the lock is already held by some thread. In this latter case, we insert the current thread into the donation list of the thread that currently holds the lock (making sure that the donation list is kept sorted). We then update the priority of the holder of the lock by making a call to update_thread_priority described below.

Briefly describe your implementation of lock_release.

How do you deal with multiple locks?
	

How do you deal with nested locks?

	We created update_thread_priority - a recursive function that updates the priority of a given thread and, if necessary, the priority of the thread on which the given thread has to wait. This function also ensures that every donation_list is kept sorted by threads' priorities. Update_thread_priority is called within thread_acquire, which modifies the donation_list and set_priority, which modifies the base priority of a thread.


---- SYNCHRONIZATION ----

How do you avoid race conditions within lock_acquire and lock_release?



---- RATIONALE ----

ALARM: For this problem, we combined two different solutions we came up with. One used semaphore elements in their threads, but checked every thread each tick and wake up ones that need to be woken up (being very time inefficient). The other created a semaphore that cooresponded to a thread that went to sleep and stored those semaphores in a list, waking them up at the calculated time (being very space inefficient or functionality limiting).

Our solution instead used both by having a calculated time to wake up element as well as a semaphore element in the thread structure. Then by putting the the thread in a list ordered by time to wake up, we iterate from the front of the list until we get through all threads that need to be woken up at that tick time.

By putting the semaphore in the thread struct, we manage to not have to constantly malloc and free new semaphores each time a thread goes to sleep. Furthermore, by using an ordered list, at every tick, we don't have to iterate through all running threads giving a time efficiency. A disadvantage to this design choice is that unlike both smaller solutions, we are allocating creating things that might never be used (such as the awake_semaphores given to threads that may never sleep as well as the list to store the sleeping threads). Under the assumptions that the sleep function will be widely used often and by many threads, these created things help the overall efficientcy.



PRIORITY DONATION: For this problem, we gave each thread a list that holds the incoming donations. When it is called to update through the function "update_actual_priority". When a thread hits a lock, all it does is adds to the list of the thread it wants to donate to and tells the thread to update its priority. This solution manages to discriminate between a thread's actual priority and its "base" priority, which is the priority that it returns to after being a doner.

Notice then that we need to deal with relaying donations. Suppose we have an ordering of priority of A>B>C If thread A and thread B are both waiting on lock 1 which thread C currently owns, when thread C releases the lock, A obtains the lock and B must be donating to A (in case A tries to lower its base priority).

Another option we could have used was to keep a list of locks that a thread holds. This would have given a more direct solution as we could have just 
