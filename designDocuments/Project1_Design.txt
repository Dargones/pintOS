CMSC 326
Design Document for Project #1: Alarms and Priority Scheduling with Priority Donation
Due: 28.March.2018

This plain text file should be called Project1_Design.txt and it should be completed and uploaded on Moodle.

Your submission will receive 50% of its points based on how well it passes my tests.  The remaining 50% is divided between the design document and your code quality.  The latter includes commenting, clarity, consistency with the Pintos style, and efficiency (in that order).



---- GROUP ----

Sasha Fedchin <af9562@bard.edu>
Karina Salem <ks5130@bard.edu>
Darren Tirto <dt2925@bard.edu>

---- PRELIMINARIES ----



---- DATA STRUCTURES ----

STUCTURE 1: Threads
Location: src/threads/thread.h
Three new elements were added to the thread structure specifically for the timer_sleep function to put . "awake_time" so we could keep track of each threads time to wake up. "awake_sem" was so that we could sleep and wake specific threads and "awake_elem" was to store them in a list so that we could store sleeping threads. 
@@ -4,6 +4,7 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
+#include "threads/synch.h"
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -100,6 +101,11 @@
 
     /* Owned by thread.c. */
     unsigned magic;                     /* Detects stack overflow. */
+
+    /* Elements used for putting threads to sleep */
+    int64_t awake_time;                 /* The time (in ticks) to wake up */
+    struct semaphore awake_sem;         /* Unique semaphore to put thread to sleep */
+    struct list_elem awake_elem;        /* List element to put this thread in a list */
   };
 
 /* If false (default), use round-robin scheduler.
@@ -138,4 +144,7 @@
 int thread_get_recent_cpu (void);
 int thread_get_load_avg (void);
 
+/*Define a function used for list_max() to order according to priority */
+list_less_func priority_is_less;

---- ALGORITHMS ----

How is priority scheduling implemented?  Refer critical data structures and the procedures where they are modified.
	We implement it through using list_max on our list; that returns the maximum value in the list. We use list_max in next_thread_to_run function, in which we pass priority_is_less function as a parameter, and in that way the scheduling algorithm picks the max priority value, through the priority_is_less critera. 
 	
 	We used the ready_list as a data structure. 

Briefly describe your implementation of lock_acquire.
	

Briefly describe your implementation of lock_release.

How do you deal with multiple locks?

How do you deal with nested locks?


---- SYNCHRONIZATION ----

How do you avoid race conditions within lock_acquire and lock_release?



---- RATIONALE ----

ALARM: For this problem, we combined two different solutions we came up with. One used semaphore elements in their threads, but checked every thread each tick and wake up ones that need to be woken up (being very time inefficient). The other created a semaphore that cooresponded to a thread that went to sleep and stored those semaphores in a list, waking them up at the calculated time (being very space inefficient or functionality limiting).

Our solution instead used both by having a calculated time to wake up element as well as a semaphore element in the thread structure. Then by putting the the thread in a list ordered by time to wake up, we iterate from the front of the list until we get through all threads that need to be woken up at that tick time.

By putting the semaphore in the thread struct, we manage to not have to constantly malloc and free new semaphores each time a thread goes to sleep. Furthermore, by using an ordered list, at every tick, we don't have to iterate through all running threads giving a time efficiency. A disadvantage to this design choice is that unlike both smaller solutions, we are allocating creating things that might never be used (such as the awake_semaphores given to threads that may never sleep as well as the list to store the sleeping threads). Under the assumptions that the sleep function will be widely used often and by many threads, these created things help the overall efficientcy.



PRIORITY DONATION: For this problem, we gave each thread a list that holds the incoming donations. When it is called to update through the function "update_actual_priority". When a thread hits a lock, all it does is adds to the list of the thread it wants to donate to and tells the thread to update its priority. This solution manages to discriminate between a thread's actual priority and its "base" priority, which is the priority that it returns to after being a doner.

Notice then that we need to deal with relaying donations. Suppose we have an ordering of priority of A>B>C If thread A and thread B are both waiting on lock 1 which thread C currently owns, when thread C releases the lock, A obtains the lock and B must be donating to A (in case A tries to lower its base priority).

Another option we could have used was to keep a list of locks that a thread holds. This would have given a more direct solution as we could have just 
