CMSC 326
Design Document for Project #1: Alarms and Priority Scheduling with Priority Donation
Due: 28.March.2018

This plain text file should be called Project1_Design.txt and it should be completed and uploaded on Moodle.

Your submission will receive 50% of its points based on how well it passes my tests.  The remaining 50% is divided between the design document and your code quality.  The latter includes commenting, clarity, consistency with the Pintos style, and efficiency (in that order).



---- GROUP ----

Sasha Fedchin <af9562@bard.edu>
Karina Salem <ks5130@bard.edu>
Darren Tirto <dt2925@bard.edu>

---- PRELIMINARIES ----



---- DATA STRUCTURES ----

Location: src/threads/thread.h
Three new elements were added to the thread structure specifically for the timer_sleep function to put . "awake_time" so we could keep track of each threads time to wake up. "awake_sem" was so that we could sleep and wake specific threads and "awake_elem" was to store them in a list so that we could store sleeping threads. 
@@ -4,6 +4,7 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
+#include "threads/synch.h"
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -100,6 +101,11 @@
 
     /* Owned by thread.c. */
     unsigned magic;                     /* Detects stack overflow. */
+
+    /* Elements used for putting threads to sleep */
+    int64_t awake_time;                 /* The time (in ticks) to wake up */
+    struct semaphore awake_sem;         /* Unique semaphore to put thread to sleep */
+    struct list_elem awake_elem;        /* List element to put this thread in a list */
   };
 
 /* If false (default), use round-robin scheduler.
@@ -138,4 +144,7 @@
 int thread_get_recent_cpu (void);
 int thread_get_load_avg (void);
 
+/*Define a function used for list_max() to order according to priority */
+list_less_func priority_is_less;

---- ALGORITHMS ----

How is priority scheduling implemented?  Refer critical data structures and the procedures where they are modified.

Briefly describe your implementation of lock_acquire.

Briefly describe your implementation of lock_release.

How do you deal with multiple locks?

How do you deal with nested locks?


---- SYNCHRONIZATION ----

How do you avoid race conditions within lock_acquire and lock_release?



---- RATIONALE ----

ALARM: For this problem, we combined two different solutions we came up with. One used semaphore elements in their threads, but checked every thread each tick and wake up ones that need to be woken up (being very time inefficient). The other stored semaphores in a list cooresponding to each 

